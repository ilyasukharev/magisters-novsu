## Вопросы для подготовки к вступительным экзаменам в магистратуру НовГУ
### Инструкция по обновлению: 
    1. Делаете форк репозитория
    2. Отправляете свою ИЗМЕНЕННУЮ ветку в пул реквест основного репа
    3. Ждете апрува
    4. Аминь
    5. Заголовки под тегом '###'. Пример: '### Жизненный цикл БД'.


### 1. Задачи и этапы проектирования и создания базы данных. Жизненный цикл базы данных.

Проектирование базы данных - процесс создания схемы базы данных и определения необходимых ограничений целостности.

Процесс проектирования базы данных охватывает несколько основных сфер:

	1. Проектирование объектов базы данных (таблицы, представления, индексы, триггеры, хранимые процедуры, функции, пакеты)
 	   для представления данных предметной области в базе данных;
	2. Проектирование интерфейса взаимодействия с базой данных (формы, отчеты и т.д.), т.е. проектирование приложений,
 	   которые будут сопровождать данные в базе данных и реализовывать вопросно-ответные отношения на этих данных;
 	3. Проектирование баз данных под конкретную вычислительную среду или информационную технологию 
  	   (архитектура "клиент-сервер", параллельные архитектуры, распределенная вычислительная среда);
	4. проектирование баз данных под назначение системы (интеллектуальный анализ данных, OLAP, OLTP и т.д.).

Основные этапы проектирования баз данных

1.Концептуальное (инфологическое) проектирование

	Концептуальное (инфологическое) проектирование — построение семантической (смысловой) модели предметной 
  	области, то есть информационной модели наиболее высокого уровня абстракции. Такая модель создаётся без
   	ориентации на какую-либо конкретную СУБД и модель данных. Термины «семантическая модель»,
    	«концептуальная модель» и «инфологическая модель» являются синонимами. Инфологическая модель является как образом
     	реальности, так и образом проектируемой базы данных для этой реальности.

	Чаще всего концептуальная модель базы данных включает в себя:
    		1. Описание информационных объектов, или понятий предметной области и связей между ними.
    		2. Описание ограничений целостности, т.е. требований к допустимым значениям данных и к связям между ними.

2.Логическое (даталогическое) проектирование

	Логическое (даталогическое) проектирование — создание схемы базы данных на основе конкретной модели данных,
	например, реляционной модели данных. Для реляционной модели данных даталогическая модель — набор схем
	отношений, обычно с указанием первичных ключей, а также «связей» между отношениями, представляющих собой внешние ключи.

3.Физическое проектирование

	Физическое проектирование — создание схемы базы данных для конкретной СУБД. Специфика конкретной СУБД может
 	включать в себя ограничения на именование объектов базы данных, ограничения на поддерживаемые типы данных и т.п.
  	Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с
   	физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, 
    	методов доступа к данным), создание индексов и т.д.
    
Модели «сущность-связь»

	Для представления конкретного вида и содержания инфологической модели предметной области, как уже говорилось, в основном используется модель
 	«сущность-связь» (англ. “Entity-Relationship model”), 	или ER-модель, предложенная П. Ченом[1] в 1976 г.
  	ER-модель обычно представляется в графической форме. Основные преимущества ER-моделей:

    		1. Наглядность;
		2. Модели позволяют проектировать базы данных с большим количеством объектов и атрибутов;
  		3. ER-модели реализованы во многих системах автоматизированного проектирования баз данных (например, ERWin).

Основные элементы ER-моделей:

    		1. Объект (сущность)- любой различимый объект (объект, который мы можем отличить от другого),
      		информацию о котором необходимо хранить в базе данных. Сущностями могут быть люди, места, самолеты, рейсы, вкус,
		цвет и т.д.;

    		2. Атрибут объекта - поименованная характеристика сущности. Его наименование должно быть уникальным 
      		для конкретного типа сущности, но может быть одинаковым для различного типа сущностей 		
		(например, ЦВЕТ может быть определен для многих сущностей: СОБАКА, АВТОМОБИЛЬ, ДЫМ и т.д.). 
  		Атрибуты используются для определения того, какая информация должна быть собрана о сущности.
    		Примерами атрибутов для сущности АВТОМОБИЛЬ являются ТИП, МАРКА, НОМЕРНОЙ ЗНАК, ЦВЕТ и т.д.

    		3. Ключ – минимальный набор атрибутов, по значениям которых можно однозначно найти требуемый экземпляр сущности.
      		Минимальность означает, что исключение из набора любого атрибута не позволяет идентифицировать сущность
		по оставшимся. Для сущности Расписание движения самолетов ключом является атрибут Номер_рейса или набор: 
  		Пункт_отправления, Время_вылета и Пункт_назначения (при условии, что из пункта в пункт вылетает в каждый момент времени один самолет).

    		4. Связь – ассоциирование двух или более сущностей. Если бы назначением базы данных было только хранение отдельных,
      		не связанных между собой данных, то ее структура могла бы быть очень простой. Однако одно из основных
		требований к организации базы данных – это обеспечение возможности отыскания одних сущностей по значениям других,
  		для чего необходимо установить между ними определенные связи. А так как в реальных базах данных нередко содержатся
    		сотни или даже тысячи сущностей, то теоретически между ними может быть установлено более миллиона связей.
      		Наличие такого множества связей и определяет сложность инфологических моделей.

Связь между сущностями характеризуется:

    1. Типом связи (1:1, 1:N, N:М);
    2. Классом принадлежности. Класс может быть обязательным и необязательным. Если каждый экземпляр
    сущности участвует в связи, то класс принадлежности — обязательный, иначе — необязательный.


Жизненный цикл БД включает в себя 7 этапов:

    а. Предварительное планирование БД
    б. Проверка возможности существования (есть ли необходимые технологии для определения БД)
    в. Определение требований (цели, потребности, требования к обороудованию, ПО)
    г. Концептуальное проектирование (Создаются модели данных на основе пользовательских представлений,
      затем эти представлений складывают воедино 
       и получают че то вразумительное, ну или иными словами - концепцию БД)
    д. Логическое проектирование (Выбор типа модели данных, идет следом за концептуальным)
    е. Физическое проектирование (расширение модели данных с учетом всех факторов и рекомендаций для
       дальнейшего деплоя в сетку приложений)
    ж. Оценка и поддержка БД
  
  Предварительное планирование конкретной системы управления базами данных осуществляется в процессе разработки стратегического
     	плана. Ищутся ответы на следующие вопросы:
      
    		а. Сколько используется прикладных программ и какие функции они выполняют?
    		б. Какие файлы связаны с каждым из этих приложений?
		в. Какие новые приложения и файлы находятся в процессе создания?

	Проверка осуществимости включает подготовку отчетов по следующим вопросам:

   		а. Технологическая осуществимость. Есть ли технология, необходимая для реализации запланированной базы данных?
    		б. Операционная осуществимость. Располагает ли компания персоналом, средствами и экспертами,
      		   необходимыми для успешного осуществления плана создания базы данных?
    		в. Экономическая целесообразность. Можно ли определить выгоды? Окупается ли запланированная система? Можно ли измерить издержки и выгоду?

	Определение требований включает выбор целей базы данных, выяснение информационных потребностей различных отделов\
 	и руководителей компании и требований к оборудованию и программному обеспечению.

	Этап концептуального проектирования включает создание концептуальной схемы базы данных. Спецификации
 	разрабатываются в той степени, которая требуется для перехода к реализации. На этом этапе создаются подробные модели
  	пользовательских представлений данных; затем они интегрируются в концептуальную модель, фиксирующую все элементы
   	корпоративных данных, которые будет содержать база данных.

	В процессе реализации базы данных выбирается и приобретается СУБД, затем подробная концептуальная модель превращается
 	в проект реализации базы данных; создается словарь данных, база данных наполняется данными, создаются
  	прикладные программы и обучается пользователь.

	Оценка включает опрос пользователей с целью выяснения, какие информационные потребности остались неучтенными.
 	В случае необходимости вносятся изменения. Обеспечивается поддержка системы путем внесения изменений и добавления новых программ и элементов данных по мере расширения и изменения потребностей 	бизнеса. 

Источники:
  
1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 2. Запросы к базе данных. Виды запросов. Язык SQL. Запросы по образцу (QВЕ).

#### **Запрос**
Каждая СУБД должна предоставлять возможность чтения, добавления, изменения и удаления записей из БД со стороны пользователя СУБД (чаще всего пользователем СУБД выступают информационные системы), если, конечно, у него есть **соответствующие права**. Для достижения этой цели в СУБД предусмотрен **язык запросов**, представляющий набор основных правил, которым должны следовать все запросы к СУБД.

Вид запросов, главным образом, зависит от модели данных, которая используется в СУБД. Если модель данных поддерживает определенный порядок элементов ( например “модель инвертированных таблиц”, “иерархическая модель”), то все запросы к СУБД начинаются с операции позиционирования ( необходимо явно переместиться на определенный объект БД ). Если же модель данных состоит из объектов, не поддерживающих порядок, как, например, **“реляционная модель данных”**, в которой все таблицы представляют собой множество кортежей, то операция позиционирования не требуется и можно писать запросы в декларативном виде. 
#### **Язык SQL**
Обычно языки БД разделяются на два вида:

1. DDL (Data definition language) - язык определения схемы базы данных.
2. DML (Data manipulation language) - язык манипулирования данными.

Язык SQL объединяет в себе обе функции, т.е. язык SQL используется как для определения схемы БД, так и для написания запросов.
#### **Определения БД**
Основным элементом определения схемы БД в языке SQL является оператор CREATE TABLE, который создаёт новую таблицу. При создании новой таблицы можно указать имена столбцов, типы значений, которые будут храниться в этих столбцах ( целочисленный тип, тип с плавающей точкой, тип строки, тип даты и т.д.). Также для каждого столбца можно указать значение по умолчанию, обозначить соответствующий столбец как первичный ключ, или как внешний [1]. Общий вид операции создания новой таблицы представлен ниже:

    CREATE TABLE имяТаблицы (
    имяСтолбца1 тип1 [дополнительныеУсловия1],
    имяСтолбца2 тип2 [дополнительныеУсловия2],
    имяСтолбца3 тип3 [дополнительныеУсловия3],
    ...
    );

В качестве примера демонстрируется создания таблицы служащих, в которой содержится номер паспорта (целочисленное, первичный ключ), имя (строка) и номер отдела, в котором работает служащий (целочисленное, внешний ключ к столбцу **Номер** таблицы **Отделы.**

    CREATE TABLE Служащие (
    Номер_паспорта int PRIMARY KEY,
    Имя varchar(255),
    Номер_отдела int FOREIGN KEY REFERENCES Отделы(Номер)
    );

##### **Манипулирования данными**
##### **SELECT**
Основным элементом манипулирования данными языка SQL является оператор выборки, общая форма которого представлена ниже [2]:

    SELECT [DISTINCT] списокСтолбцов1
    FROM списокСсылокНаТаблицы
    [WHERE условноеВыражение1]
    [GROUP BY списокСтолбцов2]
    [HAVING условноеВыражение2]
    [ORDER BY списокСтолбцов3]

На данном изображение разделы, помещенные в квадратные скобки являются необязательными и их можно пропустить.

Выборка данных производиться из одной или нескольких таблиц, представленных в разделе **FROM.** 

    SELECT attribute
    FROM table;

Если таблиц больше одной, то, перед выполнением выборки, они объединяются в одну путём операции расширенного **Декартового умножения**. 

    SELECT attribute1, attribute2
    FROM table1, table2;

Также таблицы в разделе FROM могут быть полученные в результате применения другого оператора SELECT.

На следующем шаге происходит фильтрация на основе условия, определённого в разделе **WHERE**. При пропуске раздела WHERE фильтрации не происходит и все выбранные строки переходят дальше. Ниже показано использование WHERE в запросе, получающий имена всех служащих из таблицы “Служащие”, которые имеют зарплату более 40000 рублей.

    SELECT Имя
    FROM Служащие
    WHERE Зарплата > 40000;

Раздел **GROUP BY** позволяет группировать результаты по указанным атрибутам. При его использовании в разделе SELECT разрешается использовать только имена тех столбцов, по которым осуществляется группировка, а также агрегатные функции:

- COUNT(\*) - подсчитать число элементов внутри группы
- MIN(столбец) - минимальное значение столбца внутри группы
- MAX(столбец) - максимальное значение столбца внутри группы
- и другие

Раздел **HAVING** действует аналогично разделу WHERE, только условия применяются не к отдельным строкам, а к всей группе. Если раздел HAVING присутствует, а раздел GROUP BY нет, то вся таблица воспринимается как одна группа.

В качестве примера использования разделов GROUP BY и HAVING,  демонстрируется запрос, получающий список отделов фирмы , в которых работают не менее 10 служащих:

    SELECT Номер_отдела
    FROM Отделы JOIN Служащие ON Отделы.Номер_отдела = Служащие.Номер_отдела
    GROUP BY Номер_отдела
    HAVING count(*) >= 10;

Раздел **ORDER BY** позволяет указать порядок сортировки значений в результирующей таблице. Можно выполнять сортировку по нескольким столбцам с указанием порядка сортировки( от большего к меньшему / от меньшего к большему ).

#### **INSERT**

Операция вставки нового значения в таблицу осуществляется с помощью оператора **INSERT INTO**, для которого необходимо указать имя таблицы, список столбцов, в которые будет происходить вставка значений, а также сами значения вставки [3]. Общий вид операции вставки представлен ниже:

    INSERT INTO имяТаблицы (столбец1, столбец2, столбец2, ...)
    VALUES (значение1, значение2, значение3, ...);

В качестве примера приводится операция вставки нового служащего в таблицу Служащие:

    INSERT INTO Служащие (Номер_паспорта, Имя, Номер_отдела)
    VALUES (314159, “Иванов Иван Иванович”, 2718);

Для удаления данных из таблицы необходимо использовать оператор **DELETE FROM**, общий вид которого представлен ниже [4]:

    DELETE FROM имяТаблицы WHERE условие;

После выполнения данного запроса, из таблицы **“имяТаблицы”** будут удалены все записи, для которые было выполнено условие в разделе WHERE.

#### **QBE**

Теоретическую основу языка QBE составляет реляционное исчисление доменов. С помощью языка QBE можно создавать сложные запросы к базе данных, заполняя предлагаемую СУБД форму запроса. Данный способ создания запросов позволяет получить высокую наглядность и не требует указывать алгоритм выполнения операции. Каждая современная реляционная СУБД содержит свой вариант QBE.
В качестве использования QBE, демонстрируется запрос на получение имён всех служащих из таблицы Служащие, которые работают в отделе 8128:

В данном примере демонстрируется следующие:

    +----------------+-----+--------------+
    | Номер_паспорта | Имя | Номер_отдела |
    +----------------+-----+--------------+
    |                |P.   | 8128         |
    +----------------+-----+--------------+


1. Для того, чтобы включить столбец в результирующую таблицу, необходимо вписать в соответствующие поле строку “P.” ( первая буква слова Print)
2. Есть необходимо отфильтровать результаты по значению в определённом столбце, необходимо просто указать в соответствующие поле необходимое значение.
3. Есть столбец не используется в фильтрации и не включается в результирующую таблицу, то соответствующие ему поле просто пропускается.

#### **Источники**

1. SQL CREATE TABLE Statement: <https://www.w3schools.com/sql/sql_create_table.asp>
2. SQL SELECT Statement: <https://www.w3schools.com/sql/sql_select.asp>
3. SQL DELETE Statement: <https://www.w3schools.com/sql/sql_delete.asp>
4. SQL UPDATE Statement: <https://www.w3schools.com/sql/sql_update.asp>


### 3. Язык SQL. Агрегатные функции языка. Группирование результатов. Вложенные запросы.

### **3.1 - Язык SQL**

Язык SQL (Structured Query Language т.е. "язык структурированных запросов") - язык программирования, разработанный для работы с реляционными базами данных: создания, модификации и управлением данными и таблицами их хранящими. Является декларативным языком, т.е. описывает ожидаемый результат выполнения программы. В настоящее время разрабатываются SQL-запросы к Системам Управления Баз Данных (СУБД), а как обработать запрос пользователя - решает сама СУБД. 
К текущему моменту является языком мирового стандарта работы с реляционными базами данных. Имеет множетство различных видов реализации языка запросов (называемых диалектами), таких как PostgreSQL, MS SQL Server, MySQL и т.д., различающихся специфичными, для одноимённых СУБД, элементами, расширяющими базовые возможности SQL, описанные в стандарте. 
Бозовыми, для языка SQL, являются операторы:
    Определения данных (таблиц, представлений, пользователя):
        CREATE - создание объекта базы данных 
        ALTER  - изменение объекта
        DROP   - удаление объекта
    Манипулации данными (данными в таблице):
        SELECT - выбор данных, удовлетворяющим условиям
        INSERT - добалвение новых данных
        UPDATE - обновление существующих данных
        DELETE - удаление данных
    Определния доступа к данным (разграничением доступа пользователей базы данных):
        GRANT  - предоставляет доступ на выполнение действий (см. предыдущие элементы языка) пользователю/группе
        REVOKE - отзывает ранее выданный доступ
        DENY   - определяет полный запрет на выполнение действий
    Управления транзакциями (последовательностью действий, являющейся атомарной, т.е такой, что ни одна из операций не может быть выполнена, если, последовательное выполнение их не возможно):
        COMMIT    - выполняет транзакцию
        ROLLBACK  - отменяет все изменения, выполненные в рамках текущей транзакци
        SAVEPOINT - делит транзакцию на более мелкие участки
Практически каждый оператор имеет свои предложения, специфицирующие поведение оператора или объект, с которыми будет работать оператор.
Поскольку язык SQL разрабатывался с учётом возможности его использования не профессиональными программистами - его синтаксис очень сильно напоминает обычный разговорный язык. Для примера представим запрос на выбор данных:
SELECT 'какое поле выбрать?' FROM 'из какого объетка? (таблицы)';
Если нужно ограничить выбор данными с определёнными условиями и выбрать сразу же все записи из таблицы, пользователь задаёт нужные значения полей, используя привычные конструкции:
SELECT 'название_поля' FROM 'имя_таблицы' WHERE 'название_поля' > 2;
Получается достаточно легко читаемое предложение: 
ВЫБРАТЬ 'название_поля' ИЗ ТАБЛИЦЫ 'имя_таблицы' ГДЕПОЛЕУДОВЛ.УСЛОВИЮ 'название_поля' ОПЕРАТОР_УСЛОВИЯ 'значение_поля';

### **3.2 - Агрегатные функции языка**
Агрегатные функции, называемые так же "обобщающими" или итоговыми, в текущем стандарте SQL представлены 5-ью функциями:
    COUNT, SUM, AVG, MIN, MAX
Используются в предложениях "SELECT", описывая, что нужно сделать с данными в указанном поле. SQL запрос принимает вид (на примере функции MAX):
SELECT **MAX**('название_поля') FROM 'имя_таблицы' 
При этом выборка может быть уточнена оператором WHERE. Агрегатная функция будет применена только к удовлетворяющим условиям WHERE результатам. 

Возвращаясь к функциям, рассмотрим их функционал. Любая агрегатная функция, вместо выборки конкретных данных, имеющихся в таблице, запрос вернёт единственное значение. 
    Сами названия функций лаконично описывают результат их работы:
    COUNT - Возвращает количество всех строк, полученных в результате выполнения запроса. 
    SUM   - Вовзращает сумму всех значений в указанном столбце.
    AVG   - Возвращает среднее значение в указанном столбце.
Агрегатные функции SUM и AVG работают только с числовыми данными.
    MIN   - Возвращает минимальное значение в указанном столбце.
    MAX   - Возвращает минимальное значение в указанном столбце.
Агрегатные функции MAX и MIN могут обрабатывать любые столбцы, которые можно как-либо упорядочить. 

Cтоит отметить, что возращаемый результат - одна строка и один стоблец, в единственном поле которого находится результат выполнения агрегатной функци.

Подытоживая ответ на вопрос об агрегатных функциях - это вспомогательные функции, которые помогают получать конкретный результат от СУБД, не занимаясь обработкой данных, выбранных из таблицы.

### **3.2 - Группирование результатов.**
Группирование результатов в SQL выполняется с помощью оператора GROUP BY предложения SELECT. Группирование позволяет объединять результаты выборки из таблицы на основании данных в столбцах. Рассмотрим структуру запроса:
    SELECT 'литералы, агрегатные_функции, столбцы_группировки'
    FROM 'имя_таблицы'
    GROUP BY 'столбцы_группировки';
Ключевое слово GROUP BY группирует результаты по значением полей в столбце. Все поля, имеющие равные значение (в том числе NULL будут одной группой), будут выделены в группы по этим значениям этих полей.


### **3.3 - Вложенные запросы.**
Вложенный запрос - запрос, который используется внутри другого SQL запроса. Вложенные запросы могут быть использованы везде, где разрешено использовать SQL выражения. Общим, для всех вложенных запросов, является заключение тела запроса в скобки.
Конечный результат выполнения запроса такой же, как и у обычного запроса. Порядок выполнения запросов: из центра наружу. Т.е. сначала выполняется самый "глубокий" по уровню вложенности запрос, с результатами которого будет работать основной запрос.

Простейшим примером использования вложенных запросов является использоваение результатов вложенного запроса для вывода полной строки таблицы, удовлетворяющей условиям вложенного запроса:
    SELECT * FROM 'имя_таблицы' WHERE 'имя_столбца' = (SELECT MAX('имя_столбца') FROM 'имя таблицы')
В данном примере вложенный запрос "(SELECT MAX('имя_столбца') FROM 'имя таблицы')" вернёт максимальное ЗНАЧЕНИЕ среди всех полей столбца в основной запрос, где сравнение будет происходить между всеми полями столбца и максимальным значением. Для данного примера можно изменить агрегатную функцию на MIN и найти минимальное значение.
Но даже данный пример показывает возможные проблеммы с эффективностью вложенных функций, т.к., сначала выполняется вложенный запрос, анализирующий всю таблицу, после чего основной запрос делает выборку на таком же по объёму набору данных. При более сложных запросах и уровнях вложенности - уровень сложности выполнения таких функций растёт в геометрической прогрессии.

Вложенные запросы можно использовать со всеми предложениями/операторами/функциями языка SQL, если результат выполнения этого запросам - подходит под формат входных данных основного запроса. Следовательно - данные запросы могут быть использованы для выборки данных, как спецификатор условий выбора по результату вложенного запроса для секций WHERE, как запрос определяющий, каких полей достаточно для основного запроса для секций JOIN, FROM, в секции SELECT можно получать, используя псевдонимы, данные из связанных каким-либо полем таблиц.

Источники:

1. **ISO - International Organization for Standardization** - www.iso.org + ANSI
2. **American National Standards Institute - ANSI Home** - www.ansi.org


### 4. Управление транзакциями. Модель транзакции. Свойства транзакции. Журнализация. Проблемы многопользовательских систем. Блокировки.

#### **Транзакция**

**Транзакция** - это последовательность операций над базой данных, рассматриваемых СУБД как единое целое.

Под управлением транзакциями понимается способность управлять различными операциями над данными, которые выполняются внутри реляционной СУБД. 

Управление транзакциями необходимо для поддержания логической целостности базы данных.

Пример транзакции (SQLite):

    BEGIN TRANSACTION;

    INSERT OR ROLLBACK INTO Orders (id_product, total)
    VALUES (2, 4800);

    UPDATE OR ROLLBACK Products
        SET quantity = quantity - 6
    WHERE id_product = 2;

    INSERT OR ROLLBACK INTO Invoices (id_order, id_product, num_order, sum_order, return, date)
    VALUES (1, 2, 6, 4800, 0, DATETIME('now'));

    COMMIT TRANSACTION;

#### **Модель транзакции**

**Модель транзакции** включает в себя следующие операторы:
    
1. **Оператор COMMIT**. Если все операции успешно выполнены, то транзакция также считается успешно выполненной и СУБД фиксирует (COMMIT) все изменения данных, произведенные этой транзакцией (то есть заносит изменения во внешнюю память).

2. **Оператор ROLLBACK**. Если же хотя бы одна операция транзакции заканчивается неудачей, то транзакция считается невыполненной и производится откат (ROLLBACK) — отмена всех изменений данных, произведенных в ходе выполнения транзакции, и возврат базы данных к состоянию до начала выполнения транзакции.

3. **Оператор SAVEPOINT**. Операция точки сохранения, которая предназначена для установки в транзакции особых точек, куда в дальнейшем может быть произведен откат (при этом отката всей транзакции не происходит).

Модель транзации можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/4_1.jpg" style="width: 550px">
</p>

В этой схеме можно видеть следующие варианты работы транзакции:

1. Оператор COMMIT означает успешное завершение транзакции; его использование делает постоянными изменения, внесенные в базу данных в рамках текущей транзакции;

2. Оператор ROLLBACK прерывает транзакцию, отменяя изменения, сделанные в базе данных в рамках этой транзакции; новая транзакция начинается непосредственно после использования ROLLBACK;

3. Успешное завершение программы, в которой была инициирована текущая транзакция, означает успешное завершение транзакции (как будто был использован оператор COMMIT);

4. Ошибочное завершение программы прерывает транзакцию (как будто был использован оператор ROLLBACK).


#### **Свойства транзакции**

**Свойства транзакции** описываются аббревиатурой ACID (Atomicity, Consistency, Isolation, Durability):

1. **Свойство «Атомарность» (Atomicity)**. Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

2. **Свойство «Согласованность» (Consistency)**. Данное свойство гласит, что транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных (то есть каждая успешная транзакция по определению фиксирует только допустимые результаты). Данное свойство «вытекает» из свойства атомарности.

3. **Свойство «Изолированность» (Isolation)**. Данное свойство означает, что транзакции параллельные транзакции не должны оказывать влияние на ее результаты.

4. **Свойство «Устойчивость» (Durability)**. Свойство означает, что если транзакция выполнена, и даже если в следующий момент произойдет сбой в системе, результат сохранится.

#### **Журнализация**

В случае аппаратных или программных сбоев может привести к повреждению данных в БД. Для восстановления информации в базе данных необходимо иметь некоторую дополнительную информацию. Таким образом, для поддержания надежности хранения данных требуется избыточность данных. Для таких целей существует **журнализация**.

**Журнал** хранит изменения, выполненные транзакциями, обеспечивает атомарность и устойчивость данных в случае сбоя системы.

**Журнал** содержит значения, которые данные имели до и после их изменения транзакцией. *Write-ahead log strategy* обязывает добавлять в журнал запись о предыдущих значениях до начала, а о конечных после завершения транзакции. В случае внезапной остановки системы БД читает лог в обратном порядке и отменяет изменения, сделанные транзакциями. Встретив прерванную транзакцию БД выполняет ее и вносит изменения о ней в журнал. Находясь в состоянии на момент сбоя, БД читает лог в прямом порядке и возвращает изменения, сделанные транзакциями.

#### **Проблемы многопользовательских СУБД**

Естественным следствием развития СУБД является проблема организации совместной работы нескольких пользователей с одной и той же совокупностью данных, или, проблемы многопользовательского доступа к данным.

Если в многопользовательской системе не реализованы механизмы совместной работы нескольких пользователей, то в СУБД это может привести к следующим проблемам:

1. **Проблема «последнего изменения»**. Возникает, когда несколько пользователей изменяют одну и ту же строку, основываясь на ее начальном значении; тогда часть данных будет потеряна, так как каждая последующая транзакция перезапишет изменения, сделанные предыдущей. Выход из этой ситуации заключается в последовательном внесении изменений;

2. **Проблема «грязного чтения»**. Возможна в том случае, если пользователь выполняет сложные операции обработки данных, требующие множественного изменения данных перед тем, как они обретут логически верное состояние. Если во время изменения данных другой пользователь будет считывать их, то может оказаться, что он получит логически неверную информацию. Для исключения подобных проблем необходимо производить считывание данных после окончания всех изменений;

3. **Проблема «неповторяемого чтения»**. Является следствием неоднократного считывания транзакцией одних и тех же данных. Во время выполнения первой транзакции другая может внести в данные изменения, поэтому при повторном чтении первая транзакция получит уже иной набор данных, что приводит к нарушению их целостности или логической несогласованности;

4. **Проблема «чтения фантомов»**. Появляется после того, как одна транзакция выбирает данные из таблицы, а другая вставляет или удаляет строки до завершения первой. Выбранные из таблицы значения будут некорректны.

Решением проблемы параллельной обработки БД заключается в том, что строки таблиц блокируются, а последующие транзакции, модифицирующие эти строки, отвергаются и переводятся в режим ожидания. Решается это с помощью блокировок.

#### **Блокировки**

**Блокировкой** называется временное ограничение на выполнение некоторых операций обработки данных. Блокировка может быть наложена как на отдельную строку таблицы, отдельную таблицу, так и на всю базу данных.

Управлением блокировками на сервере СУБД занимается менеджер блокировок, контролирующий их применение и разрешение конфликтов.

Транзакции и блокировки тесно связаны друг с другом. Транзакции накладывают блокировки на данные, чтобы обеспечить выполнение требований ACID. Без использования блокировок несколько транзакций могли бы изменять одни и те же данные.

Различают следующие типы блокировок:

1. По степени доступности данных: разделяемые и исключающие;
2. По множеству блокируемых данных: строчные, страничные, табличные;
3. По способу установки: автоматические (не явные) и явные;
4. По логике реализации: пессиместическая и оптимистическая.

Пример блокировки (MS SQL):

    LOCK TABLES users WRITE;
    INSERT INTO users (name) VALUES (‘Вася’);
    UNLOCK TABLES;

Работа с транзакциями есть и в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения». В моем случае, транзакция применяется когда пользователь захочет записать данные по всем найденным клиентам в БД. В этом случае, все временно созданные объекты пытаются записаться в транзакции. Если какой-то из объектов не удалось записать, тогда вся транзакция отменяется.

    НачатьТранзакцию();

    Попытка
        Для Каждого ТекущийОбработанныйОбъект Из ОбъектыОбработки Цикл
            ТекущийОбработанныйОбъект.ОбменДанным.Загрузка = Истина;
            ТекущийОбработанныйОбъект.Записать();
        КонецЦикла;

        ЗафиксироватьТранзакцию();
    Исключение
        ОтменитьТранзакцию();
    КонецПопытки;

Также в работе применяются и блокировки. Выполнить блокировку в 1С можно с помощью специального объекта встроенного языка 1С. Сделано это следующим образом:

	БлокировкаДанных = Новый БлокировкаДанных;
	
	ЭлементБлокировки = БлокировкаДанных.Добавить("Документ.ML_ФреймОбработкиДанных");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки.УстановитьЗначение("МодельМашинногоОбучения", ТекущаяМодельМашинногоОбучения);

	БлокировкаДанных.Заблокировать();

Блокировка в моей работе необходима для того, чтобы никто из пользоватей не мог редактировать дата сет по нужной модели машинного обучения, пока данная модель обучается или производится оценка ее точности.

Источники:

1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 6. Организация процессов обработки данных в базе данных: формы, запросы, отчеты.

#### **База данных (БД)**

База данных (БД) — это имеющая название совокупность данных, которая отражает состояние объектов и их отношений в рассматриваемой предметной области. Данными называют зарегистрированную информацию, представление фактов, понятий или инструкций в форме, которая подходит для передачи, связи, обработки человеком или с помощью машины. Содержимое базы данных — прайс-листы, контакты пользователей, каталоги товаров, отчеты, статистика продаж и т. д. Изменения одной ячейки автоматически влияют на другие [1].

#### **Организация процессов обработки данных**

Организация процессов обработки данных в базах данных предполагает использование различных инструментов, таких как формы, запросы и отчеты. Каждый из этих инструментов служит определенной цели в организации процессов обработки данных.

Обработка данных включает набор различных функций и операций, которые можно разделить на три группы:
•   поиск, фильтрация и сортировка данных;
•   запросы к базе данных;
•   механизм реализации событий, правил и процедур в базе данных.

#### **Формы**

Формы — это инструмент для ввода и извлечения данных из баз данных. Формы обеспечивают удобный интерфейс для ввода и поиска данных. Формы разработаны так, чтобы отражать структуру данных в базе данных, упрощая и повышая эффективность ввода и извлечения данных. Формы можно настраивать в соответствии с конкретными потребностями организации, позволяя добавлять или удалять поля в зависимости от вводимых или извлекаемых данных.

Разрабатывая приложение, можно задавать значения всех свойств компонентов с помощью форм. При этом требуемые значения либо непосредственно вводятся в поле, либо выбираются в раскрывающихся списках. В последнем случае приложение создается с помощью мыши и не требует набора каких-либо символов на клавиатуре.

Компоненты, используемые для работы с таблицей БД, их основные свойства и значения этих свойств:

<p align="center">
    <img src="pictures/6_1.gif" style="width: 550px">
</p>

*Например, при разработке базы данных для своего проекта VR-симуляции я изменял данные с помощью форм, так как в ходе разработки приложения определялись более подходящие варианты значений текстовых заголовков, описаний. Изменение данных с помощью форм подходящий вариант для такого случая, так как изменения данных происходили часто, но они не настолько значительные, чтобы организовывать для них новый запрос вручную.*

<p align="center">
    <img src="pictures/6_2.png" style="width: 550px">
</p>

#### **Запросы**

Запросы — это инструмент, который позволяет пользователям извлекать данные из базы данных на основе определенных критериев. Запросы позволяют пользователям создавать отчеты и отвечать на вопросы о данных в базе данных. Запросы настраиваются, что позволяет пользователям указывать поля для извлечения и критерии для извлечения данных. Запросы можно сохранять и использовать повторно, что упрощает создание отчетов и ответов на вопросы о данных в базе данных.
Формирование запросов в СУБД может осуществляться в специальном редакторе (командный режим) или через наглядно-диалоговые средства (конструкторы) и пошаговые мастера формирования запросов. Сформированный запрос в виде SQL-инструкции сохраняется в файле базы данных и впоследствии специальной командой СУБД может открываться на выполнение.

С точки зрения решаемых информационных задач и формы результатов исполнения запросов их можно разделить на три группы:
•   запросы на выборку данных;
•   запросы на изменение данных;
•   управляющие запросы.

1.  Пример запроса на выборку:
    SELECT title, price FROM goods
2.  Пример запроса на изменение данных:
    UPDATE goods SET price = price / 2 WHERE price >= 100
3.  Пример управляющего запроса:
    CREATE TABLE “Виджеты”

Запросы на выборку относятся к одному из наиболее часто применяемых видов запросов. Данный вид запросов реализуется SQL-инструкцией SELECT с предложением FROM. Результатом исполнения запроса на выборку является набор данных, который представляет временную таблицу данных со структурой (поля, их типы и параметры), определяемой параметрами запроса и параметрами полей таблиц, из которых выбираются данные. Результаты запросов на выборку помещаются в специальную временную таблицу, размещаемую на период исполнения («открытия») запроса в оперативной памяти.
Важное значение для решения различных технологических информационных задач по ведению базы данных имеют запросы на изменение данных. В отличие от непосредственного ввода данных в режимах открытой таблицы или формы они вносят изменения сразу в группу записей за одну операцию. Таким образом, результатом запросов на изменение является не набор данных, как в запросах на выборку, а изменение данных в самих таблицах.
При исполнении запроса на удаление за одну операцию осуществляется удаление группы записей из одной или нескольких таблиц. Запросы на удаление реализуются SQL-инструкцией DELETE.

*Например, при разработке базы данных для своего проекта я реализовал запрос-выборку записей из таблицы “Виджеты”, где поле “Количество слайдов” равно 1, так как такие виджеты можно создать при запуске приложения без инициализации.*

<p align="center">
    <img src="pictures/6_3.png" style="width: 550px">
</p>

#### **Отчеты**

Отчеты — это инструмент для представления данных из базы данных в осмысленной и лаконичной форме. Отчеты формируются на основе данных, извлеченных из базы данных посредством запросов. Отчеты можно настроить так, чтобы они включали определенные поля и параметры форматирования данных, такие как графики, таблицы и диаграммы. Отчеты можно распечатать или отправить в электронном виде в различных форматах, таких как PDF, Excel или HTML.
Для создания отчёта необходимо выбрать источник записей. Источником записей для отчета может быть таблица, именованный или внедренный запрос. Источник записей должен содержать все строки и столбцы данных, которые требуется отобразить в отчете.
Отчёты, в отличие от форм, имеют дополнительные инструменты для улучшения восприятия данных. Примеры инструментов: добавление группировки, сортировки и итогов; выделение данных с помощью условного форматирования; настройка цвета и шрифтов; добавление логотипа или фонового рисунка.

<p align="center">
    <img src="pictures/6_4.png" style="width: 550px">
</p>

Используя формы, запросы и отчеты, организации могут эффективно организовать свои процессы обработки данных, упрощая и повышая эффективность ввода, поиска и анализа данных. Используя эти инструменты, организации могут улучшить свои процессы принятия решений и получить представление о своих данных, что позволит им принимать обоснованные решения на основе данных в своей базе данных.

В заключение, формы, запросы и отчеты являются ключевыми инструментами для организации процессов обработки данных в базах данных. Каждый из этих инструментов служит определенной цели, помогая организациям эффективно вводить, извлекать и анализировать данные из своих баз данных. Используя эти инструменты, организации могут улучшить свои процессы принятия решений, получить представление о своих данных и в итоге достичь своих стратегических целей.

Источники:
1. Ian Hickson, Web SQL Database, w3.org, https://www.w3.org/TR/webdatabase/
2. SQLite Documentation - www.sqlite.org/docs.html
3. MS SQL Documentation - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. Базы данных: учебное пособие для вузов - Кузин А. В.
5. Основы SQL: учебное пособие для вузов - Полякова Л. Н.

### 8. Система управления базами данных (СУБД). Функции и объекты СУБД.

Перед тем как дать определения СУБД, необходимо определиться с понятием базы данных.

#### **База данных**

**Базой данных** называется совокупность данных и метаданных. Метаданные представлять из себя правила о том, как должны соотноситься между собой разные элементы БД.

Если для текущего состояния БД все правила, описанные в метаданных, оказываются выполненными, то БД находится в состояние **целостности**. 

#### **Пример Базы данных**

Пусть наша база данных состоит из двух таблиц. Первая таблица хранит данные по каждому сотруднику. Заголовок данной таблице представлен ниже:

    +-----------+---------------+
    | СЛУ_НОМЕР | СЛУ_ОТД_НОМЕР |
    +-----------+---------------+

Вторая таблица хранит информацию по отделу, заголовок которой представлены ниже:

    +-----------+-------------+
    | ОТД_НОМЕР | ОТД_КОЛ_СЛУ |
    +-----------+-------------+

В каждой записи служащего столбец СЛУ\_ОТД\_НОМЕР - номер отдела из таблицы отделов, а в каждой записи отдела столбец ОТД\_КОЛ\_СЛУ - количество сотрудников в данном отделе. 

В данном примере мы имеем базу данных, в которой данными являются конкретные записи в таблицах служащие и отделы, а метаданные - правила, описанные ниже:

1. Для каждой записи из таблицы отделов ОТД\_КОЛ\_СЛУ должен равняться сумме всех служащих, у которых СЛУ\_ОТД\_НОМЕР равен ОТД\_НОМЕР текущей записи.
1. Для каждой записи из таблицы служащих должна существовать единственная запись таблицы отделов, у которой ОТД\_НОМЕР равен СЛУ\_ОТД\_НОМЕР текущей записи. 

#### **СУБД**

**СУБД** - это комплекс программных средств, посредством которых можно создавать БД и меня её состояние (добавлять, изменять и удалять записи)[1]. Также важной особенности СУБД являются механизмы поддержки целостности (проверка первичного и вторичного ключа, транзакции, восстановление после сбоев и т.д.). Примеры СУБД: SQLite, DB2, MS SQL.

#### **Функции СУБД**

#### **Управление данными во внешней памяти**

СУБД должна поддерживать определённую структуры во внешней памяти, которая будет хранить БД и набор служебной информации (индексы, журналы и т.д.).

Существует два подхода к реализации данной функции:

1. С активным использовать возможности файловой системы.
1. Использовать собственную систему именования объектов (применяется намного чаще).

Стоит также отметить, что не все СУБД хранят данные во внешней памяти, однако данных подход является самым популярным в наше время.

#### **правления буферами оперативной памяти**
Почти всегда СУБД поддерживает собственную систему буферизации данных и редко полагается на операционную систему. Так как СУБД известно намного больше о характере используемых данных, чем ОС, то СУБД может обеспечить более эффективную буферизация этих данных. 

#### **Управление транзакциями**
Транзакция позволяет объединить несколько операций над БД в один “атомарный” блок, который либо полностью выполняется, либо полностью отменяется. Управление транзакциями необходимо для обеспечения целостности БД, так как выполнения отдельных операций в транзакции может временно нарушать целостность данных [2].

#### **Журнализация **
СУБД должна иметь возможность восстанавливать целостность данных после сбоя. Основным способом достижения такой возможности является журнализация - ведение записей всех изменений над БД. Основным способом ведения журнала является протокол WAL (Write Ahead Log) - операция сначала записывается в журнал, а только потом выполняется.

#### **Объекты СУБД**
Объекты СУБД могут отличаться друг от друга в зависимости от того, какая модель данных используется.

#### **Модель данных**

**Модель данных** (МД) - это набор основным признаков и свойств, которыми должны обладать все БД, реализующие данную модель.
За историю развития баз данных было разработано множество различных МД. Ниже приведены некоторые из них:

#### **Модель инвертированных таблиц**
БД данной модели состоит из набора **упорядоченных** таблиц. Перед тем как изменить базу данных, необходимо выполнить операцию позиционирования - переместиться на необходимую строку в таблице.

#### **Иерархическая модель данных**
БД данной модели представляет собой набор переменных типа дерева. Каждый тип дерева состоит из корневого типа записи и набора типа поддеревьев, каждое из которых является некоторым типом дерева. Перед изменением БД также необходимо выполнить операцию позиционирования (переместиться от родителя к конкретному потомку, переместиться от потомка к родителю и т.д.).

#### **Реляционная модель данных**
Реляционная модель данных является самой распространённой на данный момент. БД реляционной модели данных состоит из набора **неупорядоченных** таблиц ( без порядка строк и столбцов), которую принято называть отношением [3]. 

Такой подход имеет массу приемуществ в сравнение с другими моделями данных:

1. Отсутствие порядка в таблицах приводит к отсутствию операции позиционирования. Это позволяет выполнять запросы в декларативном виде, что значительно упрощает использование СУБД.
2. Реляционный подход основан на использование фундаментальных математических конструкций - кортежей и отношений. Такое математическое определение упрощает процесс формальных рассуждений и помогает в решение задач оптимизации запросов.

#### **Источники**

1. DBMS Introduction: <https://www.w3schools.in/dbms/intro>
2. DBMS Transaction: <https://www.w3schools.in/dbms/transaction>
3. Relational Data Model: <https://www.w3schools.in/dbms/relation-data-model>

### 9. Архитектура многопользовательских СУБД. Модель сервера баз данных. Сервер приложений. Трехуровневая модель.

#### **Архитектура многопользовательских СУБД.**

**Система управления базами данных (СУБД)** — совокупность
языковых и программных средств, предназначенных для создания, ведения
и совместного использования БД многими пользователями.

В зависимости от разделения функций между клиентом и сервером выделяются несколько типов архитектур систем БД, среди них:

#### **Модель сервера баз данных.**

Основу данной модели составляют следующие механизмы:
1. Механизм хранимых процедур - как средство программирования SQL-сервера;
2. Механизм триггеров - как механизм отслеживания текущего состояния информационного хранилища
3. Механизм ограничений на пользовательские типы данных, который иногда называется механизмом поддержки доменной структуры.

В этой модели бизнес-логика разделена между клиентом и сервером.
- На сервере бизнес-логика реализована в виде хранимых процедур — специальных программных модулей, которые хранятся в БД и управляются непосредственно СУБД.
- Клиентское приложение обращается к серверу с командой запуска хранимой процедуры, а сервер выполняет эту процедуру и регистрирует все изменения в БД, которые в ней предусмотрены. По итогу, сервер возвращает клиенту данные, релевантные его запросу, которые требуются клиенту либо для вывода на экран, либо для выполнения части бизнес-логики, которая расположена на клиенте.
    
Централизованный контроль в модели сервера баз данных выполняется с использованием механизма триггеров. Триггеры также являются частью БД. Механизм использования триггеров предполагает, что при срабатывании одного триггера могут возникнуть события, которые вызовут срабатывание других триггеров. Этот мощный инструмент требует тонкого и согласованного применения, чтобы не получился бесконечный цикл срабатывания триггеров.

В данной модели сервер является активным, потому что не только клиент, но и сам сервер, используя механизм триггеров, может быть инициатором обработки данных в БД. И хранимые процедуры, и триггеры хранятся в словаре БД, они могут быть использованы несколькими клиентами, что существенно уменьшает дублирование алгоритмов обработки данных в разных клиентских приложениях. Данную модель поддерживают большинство современных СУБД.

Модель сервера баз данных можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/9_1.jpg">
</p>

#### **Сервер приложений. Трехуровневая модель.**

Эта модель является расширением двухуровневой модели. Данная архитектура предполагает наличие дополнительного сервера приложений, который проводит предварительную обработку запросов клиентов, формирует запросы к серверу БД и обрабатывает полученные результаты перед отправкой их клиенту.

В этой модели компоненты приложения делятся между тремя исполнителями:

1. Клиент обеспечивает логику представления, включая графический пользовательский интерфейс, локальные редакторы; клиент может запускать локальный код приложения клиента, который может содержать обращения к локальной БД, расположенной на компьютере-клиенте. Клиент исполняет коммуникационные функции front-end части приложения, которые обеспечивают доступ клиенту в локальную или глобальную сеть. Дополнительно реализация взаимодействия между клиентом и сервером может включать в себя управление распределенными транзакциями, что соответствует тем случаям, когда клиент также является клиентом менеджера распределенных транзакций.

2. Серверы приложений составляют новый промежуточный уровень архитектуры. Они спроектированы как исполнения общих незагружаемых функций для клиентов. Серверы приложений поддерживают функции клиентов как частей взаимодействующих рабочих групп, поддерживают сетевую доменную операционную среду, хранят и исполняют наиболее общие правила бизнес-логики, поддерживают каталоги с данными, обеспечивают обмен сообщениями и поддержку запросов, особенно в распределенных транзакциях.

3. Серверы баз данных в этой модели занимаются исключительно функциями СУБД: обеспечивают функции создания и ведения БД, поддерживают целостность реляционной БД, обеспечивают функции хранилищ данных (warehouse services). Кроме того, на них возлагаются функции создания резервных копий БД и восстановления БД после сбоев, управления выполнением транзакций и поддержки устаревших (унаследованных) приложений (legacy application).

Преимущества трехуровневой модели наиболее заметны в тех случаях, когда клиенты выполняют сложные аналитические расчеты над базой данных. 

Трехуровнивую модель можно видеть на следующей схеме:

<p align="center">
    <img src="pictures/9_2.jpg">
</p>

Трехуровневая модель применяется и в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения». Применяется она следующим образом: вся бизнес-логика реализована на сервере 1С, который может выполнять различные запросы на добавления, чтения, изменения или удаления данных на сервер БД. Результаты работы с БД сервер 1С отправляет пользователям, которые используют тонкий клиент 1С. Результаты работы отображаются в виде изменных форм приложения или различных сообщений, отчетов и прочего.

Схему работы можно видеть ниже:

<p align="center">
    <img src="pictures/9_3.jpg">
</p>

1. **Web SQL Database** - www.w3.org
2. **SQLite Documentation** - www.sqlite.org/docs.html
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/sql-server/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 10. Архитектура многопользовательских СУБД. Модели двухуровневой технологии "клиент-сервер". Файловый сервер. Модель удалённого доступа к данным.

**Система управления базами данных (СУБД)** — совокупность
языковых и программных средств, предназначенных для создания, ведения
и совместного использования БД многими пользователями.

В зависимости от разделения функций между клиентом и сервером выделяются несколько типов архитектур систем БД, среди них:

### **10.1 - Модели двухуровневой технологии "клиент-сервер".**

Вычислительная модель клиент-сервер исходно связана с парадигмой открытых систем, которая появилась в 90-х годах и быстро развивалась. Термин клиент-сервер исходно применялся к архитектуре, при которой клиентский процесс запрашивает некоторые услуги, а серверный процесс обеспечивает их выполнение.

Реализация архитектуры клиент - сервер, применительно к разработке БД   позволяет более полно использовать ресурсы сети. Нагрузка равномерно распределяется между компьютером сервером и компьютером клиентом, который также как и сервер обладает собственными ресурсами.

Основной принцип технологии клиент – сервер, применительно к технологии БД, заключается в разделении функций стандартного интерактивного приложения на 4 группы, имеющих различную природу:
    Презентационная логика  - Функции ввода и отображения данных.
    Бизнес логика           - Прикладные функции, определяющие основные алгоритмы решения задач приложения.
    Логика обработки данных - Функции обработки данных внутри приложения .
    Служебные функции, играющие роль связок между функциями первых 3-х групп.

Следовательно, модели технологии можно выделить опираясь на то, какой функционал возьмёт на себя клиент и сервер. Если разбить группы вышеуказанных функций на более мелкие подзадачи, то классифицировать модели разделения можно будет практически бесконечно.
В общем виде выделяют лишь две модели: тонкий и толстый клиенты, которые различаются объёмом функционала, который берёт на себя клиент. Можно выделить ещё 2 группы - данные на клиенте и данные на сервере, т.к. сервер может быть в роли обработчика данных, а каждый отдельный клиент иметь свои базы данных, храние которых на сервере просто не требуется.

### **10.1 - Файловый сервер. **

Модель файлового сервера, в рамках СУБД, представляет собой клиент-серверную модель, где серверная машина выполняет функции файлового хранилища под управлением СУБД. На клиенте же распологается интерфейс доступа, логика обработки данных и их изменения.
На файл-сервер в этой модели возлагается функция только физического хранения данных. Он предоставляет рабочим станциям услуги по работе с файлами самого низкого уровня (открытие, закрытие, модификацию файлов, передачу их в канал сети и прием их из сети).
На сеть в данном случае возлагается большая нагрузка по передаче данных, т.к. файлы передаются в полном объеме от файл-сервера к клиенту и обратно.
Таким образом, при использовании файл-серверной модели, манипулированием данных занимаются несколько независимых и несогласованных между собой программ, работающих на различных рабочих станциях. Большую проблему в такой структуре представляет обеспечение целостности базы данных, когда пользователи со своих рабочих станций пытаются в одно и то же время внести в нее противоречивые изменения. Следует отметить, что для выполнения любой обработки данных (поиск, модификация, выполнение логических и математических процедур и т.д.) данные по всем открытым файлам необходимо передать по сети от сервера до рабочих станций и обратно после обработки и закрытия файлов.


### **10.1 - Модель удалённого доступа к данным.**

В этой модели презентационная логика и бизнес-логика располагаются на клиенте. На сервере располагается база данных и ядро СУБД.

Эти системы неудобны с точки зрения модификации и сопровождения. Даже при незначительном изменении функций системы требуется переделка всей прикладной части. Так как на клиенте расположена и презентационная логика и бизнес-логика приложения, то при повторении аналогичных функций  в разных приложениях код соответствующей бизнес-логики должен быть повторен для каждого клиентского приложения. В этой модели по сети передаются SQL-запросы, в ответ на запросы клиент получает  не блоки файлов, а только данные, релевантные запросу.

Сервер в этой модели играет пассивную роль, поэтому функции информационного управления должны выполняться на клиенте. Например, если необходимо выполнять контроль страховых запасов на складе, то каждое приложение, которое связано с изменением состояния склада, после выполнения операций модификации данных, имитирующих продажу или удаления товара со склада, должно выполнять проверку на объем остатка.  В случае если он меньше страхового запаса, необходимо формировать соответствующую заявку на поставку требуемого товара. Это может вызвать необоснованный заказ дополнительных товаров несколькими приложениями.

Достоинство модели – наличие большого числа готовых СУБД, имеющих SQL - интерфейсы и набор инструментальных средств, обеспечивающих создание клиентских приложений.  Основное достоинство – унификация интерфейса клиент-сервер, стандартом при общении клиента и сервера становится язык SQL.  
Недостатки: достаточно высокая загрузка системы передачи данных, вследствие того, что вся логика сосредоточена в приложении, а обрабатываемые данные расположены на удаленном узле. 

1. **ISO - International Organization for Standardization** - www.iso.org
2. **American National Standards Institute - ANSI Home** - www.ansi.org
3. **MS SQL Documentation** - www.learn.microsoft.com/ru-ru/sql/
4. **Базы данных : учеб, пособие для вузов** - Кузин А. В.
5. **Основы SQL : учеб, пособие для вузов** - Полякова Л. Н.

### 11. Основные алгоритмические структуры. Операторы условного и безусловного перехода. Циклические структуры, включая цикл foreach.

#### ***Основные алгоритмические структуры.***

**Алгоритмическая структура** - это структура, где каждая часть предназначена для выполнения определенного алгоритма преобразования информации 

Логическая структура любого алгоритма может быть представлена комбинацией трех базовых структур: *следование*, *ветвление*, *цикл*.

Самая простая из них - это **следование**. **Следование** — это часть алгоритма, в которой все команды исполняются одна за другой в порядке их записи. Алгоритм, в котором есть структура «следование» называется линейным. действие_1 действие_2 ... действие_n.

Схема:

<p align="center">
    <img src="pictures/11_1.svg" style="background: white; width: 150px">
</p>

Пример (Си):

    int a = 5;
    int b = 10;
    int c = a + b;

#### ***Операторы условного и безусловного перехода.***

Следующая группа алгоритмических структур - операторы условного и безусловного перехода.

**Ветвление** – это выбор действия в зависимости от выполнения какого-нибудь условия. Алгоритм, в котором есть структура «ветвление» называется разветвляющимся. 

Структура ветвление существует в четырех основных вариантах:

1. **если–то**; в этом случае выполнится действие (или группа действий), расположенное в строке то только при соблюдении условия. Если же условие не соблюдается, то исполнитель перейдет к выполнению действий, следующих за служебным словом все.

    Схема:

    <p align="center">
        <img src="pictures/11_2.svg" style="background: white; width: 150px">
    </p>

    Пример (Си):

        if (a > b) {
            return a;
        }

2. **если–то-иначе**; здесь представлена полная форма ветвления. В полной форме в зависимости от условия в строке если выполняется только одно из действий ( или группа действий), расположенных либо в строке то (условие соблюдено), либо в строке иначе (условие не соблюдено).

    Схема (Общая):

    <p align="center">
        <img src="pictures/11_3.svg" style="background: white; width: 400px">
    </p>

    Пример (Си):

        if (a > b) {
            return a;
        } else {
            return b;
        }

    Или пример с множественным ветвлением (Си):

        if (a > b) {
            return a;
        } else if (b > a) {
            return b;
        } else {
            return c;
        }

3. **Оператор множественного выбора**; Данный оператор сопоставляет значение заданного выражения с заранее предусмотренными вариантами. В большинстве языках реализован через оператор switch. Любую конструкцию выбора можно переписать в стандартное ветвление.

    Схема:

    <p align="center">
        <img src="pictures/11_4.svg" style="background: white; width: 500px">
    </p>

    Пример (Си):

        switch (keyCode) {
            case 1:
                // Действия для значения 1.
                break;
            case 2:
                // Действия для значения 2.
                // Обратите внимание, что нет оператора break;
                // Поэтому при выполнения case 2 выполнится case 3.
            case 3:
                // Действия для значения 3.
                break;
            default:
                // Действия, если не сопоставилось не один case.
                break;
        }

**Оператор безусловного перехода**. Оператор безусловного перехода goto означает «перейти к» и применяется в случаях, когда после выполнения некоторого оператора надо выполнить не следующий по порядку, а какой-либо другой, отмеченный меткой, оператор. Все языки программирования имели в свое время, а некоторые и до сих пор предлагают оператор goto, чье имя образовано слиянием двух английских слов "go to" (перейти к).

Применение оператора безусловного перехода считается «плохим тоном», по причине того, что данный оператор может привести к созданию нечитаемого «спагетти-кода» (очень запутанного кода).

Пример (Си):

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            if (i == 3) {
                goto exit_jump;
            }
        }
        printf("%i\n", i);
    }

    exit_jump: printf("exit");

#### ***Циклические структуры, включая цикл foreach.***

И наконец, циклическая группа.

**Цикл** – это неоднократное повторение каких–либо действий. Алгоритм, в котором есть структура «цикл» называется циклическим. Обеспечивает многократное выполнение некоторой совокупности действий, которая называется телом цикла.

Основные разновидности циклов:

1. Цикл с предусловием; Цикл, который выполняется, пока истинно некоторое условие, указанное перед его началом. Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу (если условие с самого начала ложно). В большинстве процедурных языков программирования реализуется оператором while, отсюда его второе название — while-цикл.

    Схема:

    <p align="center">
        <img src="pictures/11_5.svg" style="background: white; width: 150px">
    </p>

    Пример (Си):

        int a = 0;

        while (a++ < 5) {
            printf("%i\n", a);
        }

2. Цикл с постусловием; Цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется хотя бы один раз.

    Схема:

    <p align="center">
        <img src="pictures/11_6.svg" style="background: white; width: 150px">
    </p>


    Пример (Си):

        int a = 1;

        do {
            printf("%i\n", a);
        } while (a++ < 5);

3. Цикл со счетчиком; Цикл, в котором некоторая переменная изменяет своё значение от заданного начального значения до конечного значения с некоторым шагом, и для каждого значения этой переменной тело цикла выполняется один раз. В большинстве процедурных языков программирования реализуется оператором for, в котором указывается счётчик (так называемая «переменная цикла»), требуемое количество проходов (или граничное значение счётчика) и, возможно, шаг, с которым изменяется счётчик.

    Схема:

    <p align="center">
        <img src="pictures/11_7.svg" style="background: white; width: 250px">
    </p>

    Пример (Си):

        for (int i = 1; i <= 5; i++) {
            printf("%i", i);
        }

4. Цикл foreach; Цикл, задающий выполнение некоторой операции для объектов из заданного множества, без явного указания порядка перечисления этих объектов. Такие циклы называются совместными (а также циклами по коллекции, циклами просмотра) и представляют собой формальную запись инструкции вида: «Выполнить операцию X для всех элементов, входящих во множество M».

    Пример (Python):

        lst = [1, 2, 3, 4, 5]

        for lst_elem in lst:
            print(lst_elem)

Все приведенные алгоритмические структуры и используются в моем проекте «Автоматизация извлечения информации о клиентах для базы 1С с применением машинного обучения».

Пример ветвления из проекта (Встроенный язык 1С):

	Если ЭтоДокумент Тогда
		СтандартныеРеквизитыЗаполнены	= ЗначениеЗаполнено(ОбрабатываемыйОбъект.Дата);
		СтандартныйРеквизитОтказаЗаписи	= "Дата";
	Иначе
		СтандартныеРеквизитыЗаполнены	= ЗначениеЗаполнено(ОбрабатываемыйОбъект.Наименование);
		СтандартныйРеквизитОтказаЗаписи	= "Наименование";
	КонецЕсли;

Источники:

1. **WebAssembly Core Specification** - www.w3.org
2. **The GNU C Reference Manual** - www.gnu.org/software/gnu-c-manual
3. **Информатика и программирование. Основы информатики** - Н. И. Парфилова.
4. **Алгоритмы и структуры данных** - Гагарина Л. Г.

 v 13. Классы и объекты в объектно-ориентированном программировании. Наследование и полиморфизм.

Основным понятием в объектно-ориентированном программирование является понятие объекта и класса.

#### **Объект**

Объект, в самом общем смысле, это сущность, которая объединяет в себе данные и код, который может манипулировать этими данными [1]. Достаточно часто объект обладает следующими признаками:

1. Как правило, объект является **абстракцией** некоторой реальной сущности той предметной области, в рамках которой разрабатывается программный продукт. 
2. Как правило, объект должен **поддерживать инкапсуляцию** - менять данные вне этого объекта можно только путём вызова определённого кода ( публичных методов, свойств и т.д.).

#### **Класс **

Класс - это **схема построения объекта**, в которой указываются данные (члены-данные) и код, который будет оперировать этими данными (члены-функции), а также модификаторы их доступа. Если объект получается по схеме такого класса, то его можно назвать **экземпляром** или **объектом класса**.
Стоит также отметить, что существуют другие подходы к определению классов и объектов. Так, в моём случае, определения класса даётся после определения объекта, но можно действовать наоборот: сначала определить понятие класса, а затем дать определение объекту как экземпляр класса.

#### **Модификаторы доступа**

ООП поддерживает 3 вида модификаторов доступа для членов класса:

1. **Публичный** - каждый публичный член класса доступен из вне этого класса для чтения / изменений (если это данные класса) или выполнения ( функции-члены).
2. **Приватные** - каждый приватный член класса не доступен за пределами этого класса.
3. **Защищённые** - защищённый член класса доступен всем дочерним классам и никому кроме дочерних классов.

#### **Члены-данные**

Данные класса можно разделить на два типа:

- Переменные экземпляра, которые могут отличаться у разных объектов.
- Статические переменные, которые являются общими для всех экземпляров данного класса.

#### **Члены-функции**

Функции члены бывают следующих типов:

- **Методы** - функции, которые можно вызвать у экземпляра класса и, **в общем случае**, изменить состояния этого класса (метод может и не менять состояния класса).
- **Конструкторы** - функции, которые вызываются один раз, после создания объекта класса.
- **Деструктор** - функции, которые вызываются один раз, перед уничтожением объекта класса.
- **Свойства** - пара функции для получения и записи значений, обращения к которым из вне класса ничем не отличается от обращения к открытым полям класса.

Помимо объектов и классов, методика программирования ООП активно использует механизмы **наследования** и **полиморфизма**.

#### **Наследование**

Механизм наследования позволяет **дополнить** схему уже существующего класса новыми данными и функциями, или **переопределить** уже имеющиеся функции, если, кончено, это позволяет сделать наследуемый класс (например: переопределить виртуальный метод основного класса)[2]. Когда класса B наследует класса A, то класс B называется **дочерним** по отношению к классу A, а класс A **родительским** по отношению к классу B. Основное достоинство механизма наследования неразрывно связан с полиморфизмом, который мы сейчас рассмотрим. (хотя наследования и само по себе является достаточно хорошим инструментом, позволяющим избавиться от дублирования кода).

#### **Полиморфизм**

Полиморфизм, по отношению к классам, позволяет использовать дочерний класс в тех участках кода, которые требуют использования родительского класса. Таким образом, благодаря этому механизму, между потомком и родительским классом формируются отношения вида: **подмножество основного множества**. 
Пример использования полиморфизма и наследования на ЯП C#:

    class Animal
    {
        public virtual string MakeNoise()
        {
            return string.Empty;
        }
    }

    class Dog : Animal
    {
        public override string MakeNoise()
        {
            return "woof woof";
        }
    }

    class Cat : Animal
    {
        public override string MakeNoise()
        {
            return "meow meow";
        }
    }

    class Program
    {
        static void Main()
        {
            Dog dog = new Dog();
            Cat cat = new Cat();

            ExampleMethod(dog);
            ExampleMethod(cat);
        }

        static void ExampleMethod(Animal animal)
        {
            string animalNoise = animal.MakeNoise();
            Console.WriteLine($"This animal make noise like: {animalNoise}");
        }
    }

Результат выполнения программы:

    This animal make noise like: woof woof
    This animal make noise like: meow meow 

Также в объектно-ориентированном подходе существует полиморфизм на основа **интерфейсов**, который позволяет использовать в одном и том же коде разные классы, если они “скрыты”(реализуют) определённый интерфейс, необходимы для текущей работы. 
Сами интерфейсы представляют собой перечисления определённого функционала (чаще всего перечисления сигнатур методов), который должны присутствовать с публичными модификаторами доступа в классе, реализующий данный интерфейс [3].
Пример использования интерфейсов и полиморфизма на ЯП C#:

    interface NoisyObject
    {
        string MakeNoise();
    }

    class Dog : NoisyObject
    {
        public string MakeNoise()
        {
            return "woof woof";
        }
    }

    class Cat : NoisyObject
    {
        public string MakeNoise()
        {
            return "meow meow";
        }
    }

    class Program
    {
        static void Main()
        {
            Dog dog = new Dog();
            Cat cat = new Cat();

            ExampleMethod(dog);
            ExampleMethod(cat);
        }

        static void ExampleMethod(NoisyObject noisyObject)
        {
            string noise = noisyObject.MakeNoise();
            Console.WriteLine($"This object make noise like: {noise}");
        }
    }

Результат выполнения программы:

    This object make noise like: woof woof
    This object make noise like: meow meow 

#### **Источники**

1. C# OOP: <https://www.w3schools.com/cs/cs_oop.php>
1. C# Inheritance: <https://www.w3schools.com/cs/cs_inheritance.php>
1. Interfaces - define behavior for multiple types: <https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces>

### 14. Члены класса. Атрибуты и методы. Сигнатура и тело функции. Статические члены класса. Конструкторы с параметрами и без.

Члены класса, атрибуты и методы, играют важнейшую роль в объектно-ориентированном программировании. Они представляют данные и поведение класса.

#### **Атрибуты**

Атрибуты — это переменные, которые содержат данные и определяют состояние объекта. Они могут быть разных типов, например целочисленные, с плавающей запятой, строковые или определённые пользователем объекты. Они объявлены внутри класса, и к ним можно получить доступ и изменить их с помощью экземпляров объекта или экземпляров класса. Например, класс “Person” может иметь такие атрибуты: “Name”, “Age”, “Gender”.

Пример использования атрибутов при разработке класса на языке C#:

    class Person {
        public string Name;
        public int Age;
        public GenderType Gender;
    }

#### **Уровни доступа**

Во многих языках программирования атрибутам, так же, как и другим членам класса, можно задавать различный уровень доступа к данному члену класса. Инструмент определения доступа к членам класса необходим в процессе инкапсулирования класса [1]. Основные уровни доступа это:

1. Public – член класса доступен на любом уровне – им может манипулировать сам класс, имеющий данный член; наследники класса; пользователи класса.
2. Protected – доступен для изменения самим классом, наследниками.
3. Private – доступен только для самого класса [2].

*Например, при разработке своего проекта VR-симуляции я реализовал класс ItemsGrabber, который имеет различные уровни доступа к членам класса. Класс отвечает за подбор предметов, имеет public метод GrabItem, private атрибуты класса для реализации поведения.*

    Реализация на языке C# следующая:
    public class ItemsGrabber
    {
      private const int grabMagnitude = 100;
      public void Grab(Item item) 
      { 
        if (item.magnitude < grabMagnitude) return;
        Item.grab();
      }
    }

#### **Методы**

Методы представляют поведение класса. Это функции, которые могут манипулировать атрибутами объекта или выполнять некоторые другие действия. Методы объявляются внутри класса, и доступ к ним можно получить с помощью экземпляров объекта. В том же примере класса “Person” методами могут быть “changeName”, “calculateAge” и “printInfo”.
Сигнатура функции относится к списку параметров и их типов данных для функции, а также к типу возвращаемого значения функции. Например, функция сложения двух целых чисел может иметь сигнатуру: int Add (int num1, int num2);
Тело функции относится к реализации функции и содержит фактический код функции для выполнения своей задачи. Для приведенной выше сигнатуры тело функции может быть:

    int Add(int num1, int num2) { return num1 + num2; }

#### **Статические члены класса**

Статические члены класса — это атрибуты или методы, связанные с классом, а не с экземпляром этого класса. Они объявляются с помощью ключевого слова «static», и к ним можно получить доступ без необходимости создания экземпляра объекта класса. Статические члены полезны для создания общих данных между всеми объектами класса или для реализации служебных функций, которым не требуется доступ к каким-либо данным, относящимся к конкретному экземпляру.

*Например, при разработке своего проекта VR-симуляции я реализовал класс WidgetCreator, который имел статический член класса GlobalWidgetCount, это целочисленный атрибут, который инкрементировался при создании виджета из любого экземпляра класса и декрементировался при уничтожении виджета из любого экземпляра класса.*

    Реализация на языке программирования C# следующая:
    public class WidgetCreator
    {
       private static int GlobalWidgetCount = 0;
       public static int GetGlobalWidgetCount() { return GlobalWidgetCount; }
       public Widget CreateWidget() { GlobalWidgetCount++; return new Widget(); }
       public void DeleteWidget(Widget* widget) {widget.Dispose(); delete widget; GlobalWidgetCount—;}
    }

#### **Конструкторы с параметрами и без**

Конструкторы — это специальные типы методов, которые вызываются при создании объекта класса. Они используются для инициализации атрибутов объекта. Конструкторы могут быть двух типов: с параметрами и без них.
Конструкторы без параметров являются конструкторами по умолчанию. Они не принимают никаких аргументов и имеют пустую реализацию. Например, рассмотрим следующий код:

    class Person
    {
       public string Name;
       public int Age;
       public Person() { }
    }

Приведенный выше код объявляет класс “Person” без какого-либо параметризованного конструктора. Инициализировать атрибуты “Name” и “Age” в таком случае необходимо через обращение к атрибутам экземпляра класса. Например:

    Person worker = new Person();
    Worker.Name = “Oleg”;
    Worker.Age = 22;

Конструкторы с параметрами принимают один или несколько аргументов, которые используются для инициализации атрибутов объекта. Например, рассмотрим следующий код:

    class Person
    {
       public string Name;
       public int Age;
       public Person(string name, int age)
       {
           this.Name = name;
           this.Age = age;
       }
    }

Приведенный выше код объявляет класс “Person” с параметризованным конструктором, который принимает два аргумента: “name” и “age”. Ключевое слово this используется для ссылки на текущий создаваемый объект.

<p align="center">
    <img src="pictures/14_1.png" style="background: white; width: 750px">
</p>

В заключение, понимание членов класса, включая атрибуты и методы, сигнатуру и тело функции, статические члены класса и конструкторы с параметрами и без них, необходимо для создания объектно-ориентированных программ. Эти концепции позволяют создавать хорошо спроектированный и организованный код, эффективный и удобный в сопровождении.

Источники:
1. Classes, attributes and methods - www.w3.org
2. w3schools, C++ Encapsulation - https://www.w3schools.com/cpp/cpp_encapsulation.asp
3. Microsoft, Модификаторы доступа (Руководство по программированию в C#) - https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers

### 16. Многопоточное программирование. Потоки. Асинхронное программирование.

Многопоточное программирование относится к технике создания и запуска нескольких потоков в рамках одной программы. Эти потоки могут работать одновременно, выполняя несколько задач одновременно, и могут помочь повысить производительность и эффективность программы.

В одно процессной однопоточной среде все запросы, например, к интерфейсу ввода-вывода, блокируют любое дальнейшее продвижение процесса. Любая комбинация многопроцессорной или многопоточной реализации программы позволяет пользователю приложения запрашивать несколько файлов, веб-страниц, медиаресурсов одновременно. 

В качестве примера рассмотрим взаимодействие пользователя с веб-сайтом. Поскольку ожидается, что клиент World-Wide Web будет использовать большую часть времени выполнения для операций ввода-вывода, таких как «подключение» и «чтение», можно получить высокую степень оптимизации, если несколько потоков могут выполняться одновременно. Параллельное исполнение — это строгое подмножество конкурентного исполнения. Это значит, что на компьютере с одним процессором параллельное программирование – невозможно [1].

#### **Поток**

Поток — это облегченная единица выполнения, которая может выполняться одновременно с другими потоками в программе. Потоки используются для одновременного выполнения нескольких задач и совместно используют одно и то же пространство памяти, что упрощает обмен данными между ними. Как правило, потоки управляются операционной системой, а их выполнение запланировано планировщиком.

<p align="center">
    <img src="pictures/16_1.png" style="background: white; width: 750px">
</p>

Синхронизация потоков важна в многопоточном программировании, чтобы избежать состояния гонки (race condition) и обеспечить безопасный и согласованный доступ потоков к общим данным. Такие методы, как блокировка, мониторинг, семафор и мьютекс, могут использоваться для реализации синхронизации потоков и предотвращения одновременного доступа потоков к общим ресурсам, что приводит к повреждению данных, несоответствиям и другим проблемам.

*В качестве примера синхронизации потоков приведу использование семафора при разработке своего проекта. Я использовал семафор при реализации метода, работающего с общими ресурсами. Метод асинхронно закрывает открытый в данный момент виджет, и если во время закрытия виджета другой поток снова вызовет этот метод, то возникнет ошибка.
Реализация на языке C# с использованием ключевого слова lock*:

    private static readonly object BalanceLock = new();
    public async Tak AsyncHide() 
    {
      Widget currentWidget = widgetQueue.Deque();
      lock (BalanceLock)
      {
        await InternalAsyncHide(currentWidget);
      }
    }

#### **Пул потоков**

Пул потоков — это набор потоков, которые можно использовать для одновременного выполнения задач в программе. Пул потоков управляет фиксированным количеством потоков и может выделять их задачам по мере необходимости. Пулы потоков полезны для повышения производительности и масштабируемости программы, поскольку они могут повторно использовать существующие потоки вместо создания новых для каждой задачи.

#### **Асинхронное программирование**

Асинхронное программирование — это тип программирования, который позволяет программе эффективно выполнять задачи неблокирующим образом. Это означает, что вместо того, чтобы ждать завершения задачи перед переходом к следующей, программа может продолжать выполнять другие задачи, пока первая выполняется в фоновом режиме. Этот метод полезен для задач, выполнение которых занимает много времени, таких как чтение или запись данных из файла или выполнение сложных вычислений.

<p align="center">
    <img src="pictures/16_2.png" style="background: white; width: 750px">
</p>

Асинхронное программирование может быть реализовано с использованием различных методов, таких как обратные вызовы, промисы и асинхронность/ожидание. Эти методы позволяют программе планировать задачи и обрабатывать их завершение асинхронно, что делает ее более быстрой и эффективной.

При этом асинхронная операция не предполагает использование многопоточности, ведь асинхронная операция может быть выполнена на удалённом устройстве: веб-узлом, сервером, другим устройством за пределами текущего вычислительного устройства. Отличие асинхронной операции от многопоточности изображено далее:

<p align="center">
    <img src="pictures/16_3.png" style="background: white; width: 750px">
</p>

*Например, при разработке своего проекта VR-симуляции я реализовал асинхронную операцию с продолжением работы программы. Программа асинхронно ожидает ввод пользователя на клавиатуре и реагирует созданием и открытием виджета на экране пользователя, при этом основной поток программы не блокируется и продолжает свою работу.
Реализация на языке C#*:

    public Task GetUserInput()
    {
      CancellationTokenSource token = new();
      wigetButton.onClick.addListener(token.TrySetResult);
      return token.Task;
    } 


В заключение можно сказать, что многопоточное программирование — это мощная техника, которая позволяет программам выполнять несколько задач одновременно и повышать их производительность и эффективность. Потоки, асинхронное программирование, синхронизация потоков и пулы потоков — это некоторые из важнейших концепций многопоточного программирования, которые помогают обеспечить безопасное и эффективное выполнение параллельных задач. Эти концепции необходимы для разработки высокопроизводительных и быстро реагирующих приложений в современных вычислительных условиях.

Источники:
1. Henrik Frystyk, Multi Threaded Clients, w3.org - https://www.w3.org/People/Frystyk/thesis/multithread.html
2. Microsoft, Рекомендации по работе с потоками - https://learn.microsoft.com/ru-ru/dotnet/standard/threading/managed-threading-best-practices
3. **Информатика и программирование. Основы информатики** - Н. И. Парфилова.

### 18. UMLдиаграммы: классов, вариантов использования, деятельности, последовательностей, состояний.

UML – унифицированный язык моделирования. UML - это система обозначений, которую можно применять для объектно-ориентированного анализа и проектирования.
Его можно использовать для визуализации, спецификации, конструирования и документирования программных систем.
Как и любой другой язык, UML имеет собственные правила оформления моделей и синтаксис.
С помощью графической нотации UML можно визуализировать систему, объединить все компоненты в единую структуру,
уточнять и улучшать модель в процессе работы. На общем уровне графическая нотация UML содержит 4 основных типа элементов:

    	а. Фигуры;
    	б. Линии;
    	в. Значки;
    	г. Надписи.

UML-нотация является де-факто отраслевым стандартом в области разработки программного обеспечения, ИТ-инфраструктуры и бизнес-систем.

    а. Класс (class) — категория вещей, которые имеют общие атрибуты и операции. Диаграмма классов - структурная диаграмма
    языка моделирования UML, демонстрирующая общую структуру иерархии классов системы. Диаграмма классов являет собой
    набор статических, декларативных элементов модели. Она дает нам наиболее полное и развернутое представление о связях
    в программном коде, функциональности и информации об отдельных классах.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/2cd1bf1a-5c2c-43d4-8dd8-42ff0a642655)
    	
    б. Диаграммы вариантов использования(use case) описывают взаимоотношения и зависимости между группами вариантов использования
       и действующих лиц, участвующими в процессе.
       
       Диаграмма использует 2 основных элемента: 

	1) Actor (участник) — множество логически связанных ролей, исполняемых при взаимодействии с прецедентами или
 	сущностями (система, подсистема или класс). Участником может быть человек, роль человека в системе или другая
  	система, подсистема или класс, которые представляют нечто вне сущности. 

	2) Use case (прецедент) — описание отдельного аспекта поведения системы с точки зрения пользователя.
 	Прецедент не показывает, "как" достигается некоторый результат, а только "что" именно выполняется.

  ![image](https://evergreens.com.ua/assets/images/articles/uml-diagrams/use_case_diagram.png)
  
       
    в. Диаграмма деятельности позволяет более детально визуализировать конкретный случай использования. Это поведенческая диаграмма,
       которая иллюстрирует поток деятельности через систему. Диаграммы активности UML также могут быть использованы
       для отображения потока событий в бизнес-процессе.
       Диаграмма активностей описывает динамические аспекты поведения системы в виде блок-схемы,
       которая отражает бизнес-процессы, логику процедур и потоки работ — переходы от одной деятельности к другой. 
       По сути, мы рисуем алгоритм действий (логику поведения) системы или взаимодействия нескольких систем.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/17edd229-bd53-47bd-95fa-8edcf07cdbb5)

       
    г. Диаграммы последовательности - диаграмма, на которой для некоторого набора объектов на единой временной оси показан
	жизненный цикл объекта (создание-деятельность-уничтожение некой сущности) и взаимодействие акторов 
	(действующих лиц) информационной системы в рамках прецедента.
	Диаграмма используется для уточнения диаграмм прецедентов — описывает поведенческие аспекты системы.
 	Диаграмма последовательности отражает взаимодействие объектов в динамике, во времени.
  	При этом информация принимает вид сообщений, а взаимодействие объектов подразумевает обмен этими сообщениями
   	в рамках сценария.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/dde2a491-c692-4a96-be06-e2511163be59)

 
    д. Диаграмма состояний описывает процесс изменения состояний только одного класса, а точнее – одного экземпляра
       определенного класса, т. е. моделирует все возможные изменения в состоянии конкретного объекта.
       Диаграмма позволяет визуально представить различные состояния объекта или системы и показать, 
       как они изменяются в ответ на события или внешние условия. Переходы обозначают изменение состояния и указывают,
       при каких условиях происходит переход между состояниями. События являются внешними сигналами или действиями, 
       которые вызывают переходы между состояниями.

![image](https://github.com/IlyaSukharev01/magisters-novsu/assets/60602324/cd973de5-970b-4ec8-b276-6aeb8e4025bd)


1. **Uml примеры** - https://codemanship.co.uk/parlezuml/
2. **Самоучитель UML 2.** Александр Леоненков
3. **Проектирование на UML.** Сборник задач. Валентин Полежаев, Андрей Андрианов, Антон Хританков
4. **UML 2.0. Объектно-ориентированное моделирование и разработка.** Джеймс Рамбо, М. Блаха



### 19. Рекурсивные функции и данные. Пример рекурсивного алгоритма. Достоинства рекурсии и недостатки.
	
Функция — в программировании — это поименованная часть программы, которая может вызываться из других
частей программы столько раз, сколько необходимо. Функция, в отличие от процедуры, обязательно возвращает значение.

Рекурсия — это функция, которая вызывает саму себя. Представим, что есть функция А, которая выполняет определённое действие,
— например, перемножает два значения. Внутри этой функции А в качестве одного из значений для умножения возьмём ту
же самую функцию А. Получается, что функция умножает число на саму себя и внутри ещё раз умножает число на саму себя
и так далее, до бесконечности или выполнения определённого условия.

Рекурсия функции нужна, когда требуется выполнить последовательность из одинаковых действий.
Прописывать их все слишком долго, а иногда невозможно, потому что неизвестно, сколько действий понадобится.
Например, надо создать функцию, которая выводит на экран числа от N до 1. Но конечное N неизвестно,
и нужно передавать каждый раз разное. Тут и поможет рекурсия — она каждый раз будет вызывать сама себя,
уменьшая заданное N на один, пока не дойдёт до единицы.

Рекурсия немного похожа на цикл, который тоже позволяет несколько раз повторить одно и то же действие.
Но внутри цикла функция не вызывается, только прописываются различные условия. Любую рекурсивную функцию
можно описать в виде цикла, так что теоретически рекурсии можно не использовать в коде вообще.
Однако у них есть преимущества перед циклами.


Недостатки.

      а. Скорость работы рекурсивного кода. Некоторые компиляторы могут преобразовывать хвостовую
         рекурсию в цикл, но, в целом, итеративные реализации работают быстрее практически во
         всех случаях, когда использование циклов НЕ усложняет алгоритм.
      б. Требования к размеру стека, но это решается настройками компиляции или выбором языка,
         который не ограничивает размер стека
      в. Если забыть прописать условие выхода, рекурсия будет выполняться бесконечно — программу придётся завершать принудительно.

Достоинства.

      а. Эффективность применения. Некоторые алгоритмы выглядят проще и понятнее с использованием рекурсии.
      б. Рекурсии легче реализовывать, чем итерации.
      в. Иногда код рекурсии можно упаковать в несколько строк, в то время как такой же цикл займёт
      	 десятки строк кода. В этом случае рекурсия будет выполняться быстрее аналогичного цикла.

Суть рекурсии такова, что она может вызывать сама себя вечно, никогда не заканчиваясь.
Это называется бесконечной рекурсией, выйти из которой можно только принудительным закрытием программы.

Принцип «Разделяй и властвуй» — самое популярное и частое применение для рекурсии. Декомпозиция, то есть разбиение любой
задачи на более мелкие части, — основа, на которой строится принцип рекурсии:

	1.Разделять. Решать проблему напрямую, если она небольшая. В противном случае разделить
 	задачу на меньшие подмножества той же проблемы.

	2.Властвовать. Решать меньшие задачи рекурсивно. Если подзадача достаточно мала, 
 	рекурсия не нужна и можно решить её напрямую.

	3.Комбинировать. Взять готовое решение для маленькой подзадачи и объединить с решением исходной проблемы.

	Как только большая задача будет разбита на множество мелких частей, можно использовать параллельное
 	программирование для их одновременного выполнения, ускоряя весь процесс решения.
  	Такой подход является самым быстрым и простым способом увеличить скорость алгоритма и всей программы.

Пример:

      Вычисление факториала:

      def factorial(x):
          if (x == 0):
              return 1
          return x * factorial(x - 1)

1. **Книга «Рекурсивная книга о рекурсии»** - Эл Свейгарт
2. **Искусство программирования.** Основные алгоритмы. - Дональд Кнут
3. **Функции в Python** - https://www.w3schools.com/python/python_functions.asp


    
### 20. Обработки исключительных ситуаций. 

Исключение - тип событий при выполнении программы, который приводит к неожиданному или неправильному поведению программы. 
В рамках разработки прикладных программ, исключения можно разделить на два типа:
    1. Аппаратные (структурные, SE-Structured Exception):
    которые генерируются процессором. К ним относятся, например:
            деление на 0;
            выход за границы массива;
            обращение к невыделенной памяти;
            переполнение разрядной сетки.
    2. Программные:
    генерируемые операционной системой и прикладными программами – возникают тогда, когда программа их явно инициирует. Когда встречается аномальная ситуация, та часть программы, которая ее обнаружила, может сгенерировать, или возбудить, исключение.

Основная концепция идея обработки исключительных ситуаций состоит в том, что функция, обнаружившая проблему, но не знающая как её решить, генерирует исключение в надежде, что вызвавшая её (непосредственно или косвенно) функция сможет решить возникшую проблему. Функция, которая может решать проблемы данного типа, указывает, что она перехватывает такие исключения.

Существует два принципиально разных механизма функционирования обработчиков исключений.:
    1. Обработка с возвратом - поздразумевающая, что функция-обработчик решит проблему, вызвавшую исключение, и программа продолжит работать по основному алгоритму. При этом "проблемой" может являться поступление новых данных, требующий обработки или прерывание, вызванное таймером.
    2. Обработка без возврата - заключается в том, что после выполнения кода обработчика исключения управление передаётся в некоторое, заранее заданное место программы, и с него продолжается исполнение. То есть, фактически, при возникновении исключения команда, во время работы которой оно возникло, заменяется на безусловный переход к заданному оператору.

Сами же исключения могут быть обработаны по двум принципам:
    1. Неструктурная обработка исключений -  реализуется в виде механизма регистрации функций или команд-обработчиков для каждого возможного типа исключения. Язык программирования или его системные библиотеки предоставляют программисту как минимум две стандартные процедуры: регистрации обработчика и разрегистрации обработчика. Вызов первой из них «привязывает» обработчик к определённому исключению, вызов второй — отменяет эту «привязку». Если исключение происходит, выполнение основного кода программы немедленно прерывается и начинается выполнение обработчика. По завершении обработчика управление передаётся либо в некоторую наперёд заданную точку программы, либо обратно в точку возникновения исключения (в зависимости от заданного способа обработки — с возвратом или без).

    2. Структурная обработка исключений - требует обязательной поддержки со стороны языка программирования — наличия специальных синтаксических конструкций. Такая конструкция содержит блок контролируемого кода и обработчик (обработчики) исключений. 

Рассмотрим подробнее механизм структурной обработки исключений. Он позволяет однотипно обрабатывать как программные, так и аппаратные исключения.

В многих языках программирования структурная обработка исключений реализована блоком try{...} catch(error) {...}:
     **try {защищаемый_код}** - который отслеживает выполнение кода внутри себя и при возникновении исключительной ситуации может обработать ошибку в обработчике исключений, объявляемым сразу после защищаемого кода блоком **catch (тип_исключения усл_имя) {код_обработчика}**.
    В зависимости от реализации структурной обработки в конкретном языке программирования, обработчик может быть один на абстрактный тип ошибки или множество обработчиков для каждого типа.
    
    Исключения могут быть сгенерированы программой при помощи команды **throw**, что может быть использовано в тех ситуациях, когда сам процесс выполнения ошибочного кода (или возникновения ошибочного поведения) не вызовет системного исключения. Например, программа, выполнив запрос к внешнему источнику, ожидает поступления данных от внешнего источника, но они отстуствуют и выполнение программы не может быть продолженно. Программист может запустить таймер, который, по истечении срока ожидания сгенерирует исключение, которое позволит программе продолжить выполнения, игнорируя последующие инструкции обработки данных, а пользователь получит ошибку и сможет продолжить работать с программой.

    На языке С++ обработка исключений может быть представлена как: 
    try {
        //Код, который может вызвать исключение
        throw 15; // команда, вызывающая исключение типа int со значением 15.
    } catch (int a) { //Начало блока обработчика, который может обработать исколючение типа int
        //Код обработчика
    }
    catch (...) {// Троеточие в блоке Catch - указывает, что обработчик обрабатывает все ошибки
        //Код обработчика
    }

Обработчики - удобный 

1. **IBM** - www.ibm.com 
2. **Документация по C/C++**learn.microsoft.com/ru-ru/cpp/